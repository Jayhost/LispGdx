package io.github.jayhost;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Cubemap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.PerspectiveCamera;
import com.badlogic.gdx.math.MathUtils;
import java.util.HashMap;
import java.util.List;

import net.mgsx.gltf.loaders.gltf.GLTFLoader;
import net.mgsx.gltf.scene3d.attributes.PBRCubemapAttribute;
import net.mgsx.gltf.scene3d.attributes.PBRTextureAttribute;
import net.mgsx.gltf.scene3d.scene.Scene;
import net.mgsx.gltf.scene3d.scene.SceneAsset;
import net.mgsx.gltf.scene3d.scene.SceneManager;
import net.mgsx.gltf.scene3d.scene.SceneSkybox;
import net.mgsx.gltf.scene3d.utils.EnvironmentUtil;


public class Main extends ApplicationAdapter {
    private SceneManager sceneManager;
    private PerspectiveCamera camera;
    private LispInterpreter interpreter;
    private float time;
    FPSController fps;

    // Track dynamically loaded scenes by path
    private HashMap<String, Scene> loadedScenes = new HashMap<>();

    @Override
    public void create() {
        // GL context setup
        Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);
        Gdx.gl.glDepthFunc(GL20.GL_LEQUAL);

        // Load the base model
        SceneAsset baseAsset = new GLTFLoader()
            .load(Gdx.files.internal("models/helm/DamagedHelmet.gltf"));
        Scene baseScene = new Scene(baseAsset.scene);

        // Scene manager & camera
        sceneManager = new SceneManager();
//        sceneManager.addScene(baseScene);

        camera = new PerspectiveCamera(
            90f, Gdx.graphics.getWidth(), Gdx.graphics.getHeight()
        );
        camera.near = 0.1f;
        camera.far  = 100f;
//        camera.position.set(2f, 2f, 2f);
        camera.lookAt(0f, 0f, 0f);
        camera.update();
        sceneManager.setCamera(camera);

        fps = new FPSController(camera);
        Gdx.input.setInputProcessor(fps);
        // PBR environment
        Cubemap diffuse = EnvironmentUtil.createCubemap(
            new InternalFileHandleResolver(),
            "mytex/diffuse/diffuse_", ".png",
            EnvironmentUtil.FACE_NAMES_NEG_POS
        );
        Cubemap specular = EnvironmentUtil.createCubemap(
            new InternalFileHandleResolver(),
            "mytex/specular/specular_", "_", ".png",
            10, EnvironmentUtil.FACE_NAMES_NEG_POS
        );
        Texture brdfLUT = new Texture(
            Gdx.files.internal("textures/brdfLUT.png")
        );
        sceneManager.setAmbientLight(1f);
        sceneManager.environment.set(
            new PBRTextureAttribute(
                PBRTextureAttribute.BRDFLUTTexture, brdfLUT
            )
        );
        sceneManager.environment.set(
            PBRCubemapAttribute.createSpecularEnv(specular)
        );
        sceneManager.environment.set(
            PBRCubemapAttribute.createDiffuseEnv(diffuse)
        );
        sceneManager.setSkyBox(new SceneSkybox(diffuse));

        // --- Lisp interpreter setup ---
        interpreter = new LispInterpreter();

        interpreter = new LispInterpreter();
        interpreter.run("(import io/github/jayhost/LispBridge)");

        interpreter.run("(defun add-at (path x y z) (. LispBridge addEntityAt path x y z))");
        interpreter.run("(defun add (path) (add-at path 0 0 0))");
        interpreter.run("(defun rem (path) (. LispBridge removeEntity path))");
        interpreter.run("(defun drain-spawns () (. LispBridge drainSpawns))");
        interpreter.run("(defun drain-removals () (. LispBridge drainRemovals))");
        interpreter.run("(defvar helm \"models/helm/DamagedHelmet.gltf\")");
        interpreter.run("(defvar mug \"models/mug/mug.gltf\")");
        interpreter.run("(defvar ball \"models/ball/ball.gltf\")");
        interpreter.run("(defvar barrel \"models/barrel/Barrel.gltf\")");
        interpreter.run("(defvar mosin \"models/mosin/M91.gltf\")");
        interpreter.run("(defvar bird \"models/god/bird.gltf\")");
        interpreter.run("(defvar sponza \"models/sponza/Sponza.gltf\")");

// Test initial spawn and removal
        interpreter.run("(add sponza)");
//        interpreter.run("(remove-entity \"helm/DamagedHelmet.gltf\")");
        new Thread(() -> {
            try {
                LispInterpreter.main(new String[]{}); // starts REPL
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "Lisp-REPL").start();

    }

    @Override
    public void render() {
        float dt = Gdx.graphics.getDeltaTime();
        time += dt;

        // Pull back any new paths from Lisp


        Object spawnRaw = interpreter.eval("(drain-spawns)");
        if (spawnRaw instanceof java.util.List) {
            for (Object o : (java.util.List<?>)spawnRaw) {
                SpawnRequest req = (SpawnRequest)o;
                if (!loadedScenes.containsKey(req.path)) {
                    SceneAsset a = new GLTFLoader()
                        .load(Gdx.files.internal(req.path));
                    Scene s = new Scene(a.scene);
                    // position the modelInstance
                    s.modelInstance.transform.setToTranslation(req.position);
                    sceneManager.addScene(s);
                    loadedScenes.put(req.path, s);
                }
            }
        }

        // Handle removals
        Object removeRaw = interpreter.eval("(drain-removals)");
        if (removeRaw instanceof java.util.List) {
            for (Object o : (java.util.List<?>)removeRaw) {
                String path = (String)o;
                Scene s = loadedScenes.remove(path);
                if (s != null) {
                    sceneManager.removeScene(s);
                }
            }
        }


//        // Orbit camera
//        camera.position.setFromSpherical(
//            MathUtils.PI/4f, time * 0.5f
//        ).scl(2f);
        float radius = 2f;
        float angle = time * 0.5f;
        float x = MathUtils.cos(angle) * radius;
        float z = MathUtils.sin(angle) * radius;
        camera.position.set(x, 1f, z);  // constant Y height
        camera.lookAt(0f, 1f, 0f);
        camera.update();


// update FPS controller (moves camera)
//        fps.update(dt);

        // Render
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
        sceneManager.update(dt);
        sceneManager.render();

        // Debug
//        Gdx.app.log("Main", "Loaded scenes: " + loadedScenes.size());
    }

    @Override
    public void dispose() {
        sceneManager.dispose();
    }


}
