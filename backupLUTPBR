package io.github.jayhost;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector3;
import net.mgsx.gltf.loaders.gltf.GLTFLoader;
import net.mgsx.gltf.scene3d.attributes.PBRCubemapAttribute;
import net.mgsx.gltf.scene3d.attributes.PBRTextureAttribute;
import net.mgsx.gltf.scene3d.scene.Scene;
import net.mgsx.gltf.scene3d.scene.SceneAsset;
import net.mgsx.gltf.scene3d.scene.SceneManager;
import net.mgsx.gltf.scene3d.scene.SceneSkybox;
import net.mgsx.gltf.scene3d.utils.EnvironmentUtil;

public class Main extends ApplicationAdapter {
    private SceneManager sceneManager;
    private SceneAsset sceneAsset;
    private Scene scene;
    private PerspectiveCamera camera;
    private Cubemap diffuseCubemap;
    private Cubemap environmentCubemap;
    private Cubemap specularCubemap;
    private Texture brdfLUT;
    private float time;
    private SceneSkybox skybox;

    @Override
    public void create() {
        // Setup GL context
        Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);
        Gdx.gl.glDepthFunc(GL20.GL_LEQUAL);

        // Create scene with your helmet model
        sceneAsset = new GLTFLoader().load(Gdx.files.internal("helm/DamagedHelmet.gltf"));
        scene = new Scene(sceneAsset.scene);

        // Scale model if needed (GLTF models often need scaling)
        scene.modelInstance.transform.scl(1f);

        sceneManager = new SceneManager();
        sceneManager.addScene(scene);

        // Camera setup
        camera = new PerspectiveCamera(60, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        camera.near = 0.1f;
        camera.far = 100f;
        camera.position.set(2, 2, 2);
        camera.lookAt(0, 0, 0);
        camera.update();
        sceneManager.setCamera(camera);

        // Setup environment maps (replace paths with your own)
        environmentCubemap = EnvironmentUtil.createCubemap(
            new InternalFileHandleResolver(),
            "textures/environment/diffuse/diffuse_", ".png",
            EnvironmentUtil.FACE_NAMES_NEG_POS
        );

        specularCubemap = EnvironmentUtil.createCubemap(
            new InternalFileHandleResolver(),
            "textures/environment/specular/specular_", "_", ".png",
            10, // mipmaps
            EnvironmentUtil.FACE_NAMES_NEG_POS
        );

        brdfLUT = new Texture(Gdx.files.internal("textures/brdfLUT.png"));

        // Configure PBR environment
        sceneManager.setAmbientLight(0.3f);
        sceneManager.environment.set(new PBRTextureAttribute(PBRTextureAttribute.BRDFLUTTexture, brdfLUT));
        sceneManager.environment.set(PBRCubemapAttribute.createSpecularEnv(specularCubemap));
        sceneManager.environment.set(PBRCubemapAttribute.createDiffuseEnv(environmentCubemap));

        // Skybox (optional)
        skybox = new SceneSkybox(environmentCubemap);
        sceneManager.setSkyBox(skybox);
    }

    @Override
    public void resize(int width, int height) {
        sceneManager.updateViewport(width, height);
    }

    @Override
    public void render() {
        // Animate camera
        time += Gdx.graphics.getDeltaTime();
        camera.position.setFromSpherical(MathUtils.PI/4, time * 0.5f).scl(3f);
        camera.lookAt(0, 0, 0);
        camera.update();

        // Clear and render
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
        sceneManager.update(Gdx.graphics.getDeltaTime());
        sceneManager.render();
    }

    @Override
    public void dispose() {
        sceneManager.dispose();
        sceneAsset.dispose();
        environmentCubemap.dispose();
        specularCubemap.dispose();
        brdfLUT.dispose();
        if(skybox != null) skybox.dispose();
    }
}
